
// Full Files: Database, MapTree, Map
virtual T FromFile(std::string fileName) = 0;
virtual void ToFile(std::string fileName, T& elem) = 0;

// Partial Files: Character, CommonEvent, EventCommand, EventPage, Event, Item, LCFType, MapInfo, 
virtual  T FromFile(std::unique_ptr<tinyxml2::XMLDocument>& doc) = 0;
virtual std::unique_ptr<tinyxml2::XMLDocument> ToFile(T& elem) = 0;

// Multi Serializer: CommonEvent, EventCommand
virtual  std::vector<T> MultipleFromFile(std::string fileName) = 0;
virtual  void MultipleToFile(std::string fileName, std::vector<T>& elems) = 0;

// Multi Partial Serializer: EventCommand?
virtual std::vector<T> MultipleFromFile(std::unique_ptr<tinyxml2::XMLDocument>& doc) = 0;
virtual std::unique_ptr<tinyxml2::XMLDocument> MultipleToFile(std::vector<T>& elems) = 0;


// Serializer
namespace tinyxml2 {class XMLDocument; };

template <typename T>
class Serializer {
    Serializer() = delete;

private:
    // Full Files:
    virtual T FromFile(std::string fileName) = 0;
    virtual void ToFile(std::string fileName, T& elem) = 0;
    
    virtual  std::vector<T> MultipleFromFile(std::string fileName) = 0;
    virtual  void MultipleToFile(std::string fileName, std::vector<T>& elems) = 0;

    // Partial Files:
    virtual  T FromFile(std::unique_ptr<tinyxml2::XMLDocument>& doc) = 0;
    virtual std::unique_ptr<tinyxml2::XMLDocument> ToFile(T& elem) = 0;

    virtual std::vector<T> MultipleFromFile(std::unique_ptr<tinyxml2::XMLDocument>& doc) = 0;
    virtual std::unique_ptr<tinyxml2::XMLDocument> MultipleToFile(std::vector<T>& elems) = 0;
};

class Event {};

// TODO: How to reuse Serializer Code but not have 100 .h and .cpp files? Do I need these nested Serializers?
// TODO: Hide "Partial" Serializers because of the existance of tinyxml2::XMLDocument? Or is that okay?
class EventSerializer : Serializer<Event> {
private:
    // These are serializer function that we do not need in this specific implementation.
    
    // Empty private definitions we do not need.
    Event FromFile(std::string fileName) override {return Event(0, "");};
    void ToFile(std::string fileName, Event& elem) override {};
    std::vector<Event> MultipleFromFile(std::string fileName) override {return std::vector<Event>();};
    void MultipleToFile(std::string fileName, std::vector<Event>& elems) override {};
    Event FromFile(std::unique_ptr<tinyxml2::XMLDocument>& doc) override {return Event(0, "");};
    std::unique_ptr<tinyxml2::XMLDocument> ToFile(Event& elem) override {return nullptr;};
    std::vector<Event> MultipleFromFile(std::unique_ptr<tinyxml2::XMLDocument>& doc) override {return std::vector<Event>();};
    std::unique_ptr<tinyxml2::XMLDocument> MultipleToFile(std::vector<Event>& elems) override { return nullptr;};
public:
    EventSerializer();
    // Only override functions that we actually need here.
    // But the generic serializer interface gives us a guideline to follow.
    Event FromFile(std::string fileName) override {
        // Real implementation here
    }
};



// Data:
class Data {
    // TODO: Only if really needed.
    friend class DataSerializer;
public:
    // Should test like this:
    //Data(/**/): id(id), name(name), x(x), y(y) {
    //assert(1 <= id < RPGMAKER::MAX_PAGES_PER_EVENT);
    //}   
    Data(/* list of all private data */);
    // could be included in the first Constructor?
    Data(/* known vector sizes to reserve space*/);

    Data(const Data& other) = delete;
    Data(Data&& other) = delete;
    operator=(const Data& other) = delete;
    operator=(Data&& other) = delete;

    // on all Add functions use: switches.emplace_back(getNextID(switches.size()), name);
    void addX(instance&&);
    void addXs(std::vector<instance>);
    instance& addX(parameters /*Constructor params, without stuff that is managed (like ids)*/);

// Make everything public that makes sense to be public (like const stuff).
// Make everything const that should not change after instantiation!
// NO uneccessary getters/Setters (use C++ Style:  X var_name(), void var_name(X))
private:
    const uint16_t unchangeableData;
    uint16_t changeleData;
    std::vector<uint16_t> someVector;
};